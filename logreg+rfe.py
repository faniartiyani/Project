# -*- coding: utf-8 -*-
"""logreg+rfe.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Axs1StudnF0WBAnIHlYe_mlzQuCxVmFC
"""

from mlxtend.plotting import plot_decision_regions
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score, StratifiedKFold
from sklearn.linear_model import LogisticRegression
from sklearn.feature_selection import RFE
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, roc_auc_score, precision_score, recall_score, f1_score
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
import pickle
sns.set()
import warnings
warnings.filterwarnings('ignore')
from sklearn.feature_selection import RFECV
from sklearn.linear_model import LogisticRegression
# Import SMOTE
from imblearn.over_sampling import SMOTE
import os
#import classification_report
from sklearn.metrics import classification_report

# Membaca dataset
dataset = pd.read_csv('./data breast cancer.csv')

dataset['concavity_mean'] = dataset['concavity_mean'].astype('float')
dataset['smoothness_worst'] = dataset['smoothness_worst'].astype('float')
dataset['compactness_worst'] = dataset['compactness_worst'].astype('float')
dataset['concavity_worst'] = dataset['concavity_worst'].astype('float')
dataset['concave points_worst'] = dataset['concave points_worst'].astype('float')
dataset['symmetry_worst'] = dataset['symmetry_worst'].astype('float')

df = pd.DataFrame(dataset)

# Mengisi nilai hilang pada fitur diagnosis dengan modus
if df['diagnosis'].isnull().sum() > 0:
    df['diagnosis'].fillna(df['diagnosis'].mode()[0], inplace=True)

# Mengonversi nilai diagnosis menjadi biner (M = 1, B = 0)
df['diagnosis'] = df['diagnosis'].map({'M': 1, 'B': 0})

# Pastikan kolom diagnosis berupa tipe kategori biner
# Jika diagnosis berupa 'M' (malignant) dan 'B' (benign), ubah menjadi 0 dan 1
label_encoder = LabelEncoder()
y = label_encoder.fit_transform(df['diagnosis'])  # 0 untuk 'B', 1 untuk 'M

# Pisahkan fitur dan target
X = df.drop('diagnosis', axis=1)
y = df['diagnosis']

# Bagi data menjadi data latih dan uji
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standarisasi hanya fitur (X)
scaler = StandardScaler()
X_scaled = pd.DataFrame(scaler.fit_transform(X), columns=X.columns)

# Gabungkan kembali jika perlu menampilkan bersama label
df_standardized = pd.concat([X_scaled, y.reset_index(drop=True)], axis=1)

# Import the necessary module
from matplotlib import cm

# Inisialisasi dan training RFECV
estimator = LogisticRegression(max_iter=10000, solver='liblinear')
rfecv = RFECV(estimator=estimator, step=1, cv=5, scoring='accuracy')
rfecv.fit(X_train, y_train)

# Ambil semua fitur, koefisien, dan ranking-nya
all_features = X_train.columns
all_rankings = rfecv.ranking_
all_support = rfecv.support_

# Estimator final dan koefisiennya
final_model = rfecv.estimator_
final_coef = final_model.coef_[0]

# Buat DataFrame gabungan
ranking_df = pd.DataFrame({
    'Fitur': all_features,
    'Dipilih': all_support,
    'Ranking': all_rankings
})

# Isi kolom koefisien hanya untuk fitur yang dipilih
selected_features = all_features[all_support]
ranking_df['Koefisien'] = ranking_df.apply(
    lambda row: final_coef[list(selected_features).index(row['Fitur'])] if row['Dipilih'] else np.nan,
    axis=1
)

# Urutkan berdasarkan ranking
ranking_df = ranking_df.sort_values(by='Ranking', ascending=True).reset_index(drop=True)

# Normalisasi biasa, tapi colormap dibalik
norm = plt.Normalize(ranking_df['Ranking'].min(), ranking_df['Ranking'].max())
cmap = cm.get_cmap("Blues_r")  # "_r" artinya reversed
mapped_colors = [cmap(norm(r)) for r in ranking_df['Ranking']]

# Plot
plt.figure(figsize=(10, 8))
sns.barplot(
    data=ranking_df,
    y='Fitur',
    x='Ranking',
    palette=mapped_colors,
    order=ranking_df['Fitur']
)

plt.title('üìä Ranking Fitur Berdasarkan RFECV (Semua Fitur)', fontsize=14)
plt.xlabel('Ranking (1 = paling penting)', fontsize=12)
plt.ylabel('Nama Fitur', fontsize=12)
plt.tight_layout()

# Simpan dan tampilkan
plt.savefig('models/logreg+rfe/ranking_fitur_berdasarkan_RFECV(Logreg).png', dpi=300)
plt.show()

# 1. Fitting RFE dengan Logistic Regression
log_reg = LogisticRegression(max_iter=1000)
rfe_log_reg = RFE(estimator=log_reg, n_features_to_select=10)
rfe_log_reg.fit(X_train, y_train)

selected_features = X_train.columns[rfe_log_reg.support_]
print("\nFitur terpilih menggunakan Logistic Regression (RFE):")
print(selected_features)

# Buat DataFrame baru dari fitur terpilih
new_data_df = X_train[selected_features]

# Cetak hasil seleksi fitur dan bentuk dataframe baru
print("Selected columns:", selected_features)
print("Input DataFrame shape:", new_data_df.shape)

# 3. Ambil koefisien dari model Logistic Regression setelah fit RFE
# Harus retrain logistic regression dengan fitur terpilih
log_reg.fit(X_train[selected_features], y_train)
coef = log_reg.coef_[0]

# 4. Buat DataFrame untuk visualisasi
coef_df = pd.DataFrame({
    'Fitur': selected_features,
    'Koefisien': coef
}).sort_values(by='Koefisien', ascending=False)

# Plot
plt.figure(figsize=(10, 6))
sns.barplot(x='Koefisien', y='Fitur', data=coef_df, palette='Blues_r')
plt.axvline(0, color='gray', linestyle='--')
plt.title('üîç Fitur Terpilih Berdasarkan RFE (Logistic Regression)')
plt.xlabel('Koefisien Pentingnya Fitur')
plt.ylabel('Nama Fitur')

# Tambahkan label nilai koefisien
for i, (value, name) in enumerate(zip(coef_df['Koefisien'], coef_df['Fitur'])):
    plt.text(value, i, f'{value:.2f}', va='center',
             ha='left' if value > 0 else 'right', color='black')

plt.tight_layout()

# ‚¨ÖÔ∏è Pindahkan simpan ke sini, sebelum show
plt.savefig('models/logreg+rfe/fitur_terpilih_rfecv_logreg.png', dpi=300)
plt.show()

from sklearn.preprocessing import StandardScaler

# Create a StandardScaler object
scaler = StandardScaler()

# Fit the scaler to the training data and transform it
X_train_scaled = scaler.fit_transform(X_train)

# Transform the test data using the fitted scaler
X_test_scaled = scaler.transform(X_test)

# GridSearchCV dengan Penalti Lebih Kuat
param_grid = {
    'C': [0.0001, 0.0005, 0.001],
    'penalty': ['l1', 'l2'],  # Regularisasi L1 dan L2
    'solver': ['liblinear'],
    'max_iter': [50],
    'class_weight': ['balanced']  # Mengatasi imbalance
}

# Cross-Validation Lebih Ketat
grid_search_before = GridSearchCV(
    LogisticRegression(random_state=42),
    param_grid,
    cv=3,                     # CV lebih tinggi
    scoring='f1',              # Fokus pada f1-score
    n_jobs=-1
)

# Now you can proceed with your GridSearchCV, after defining it
grid_search_before.fit(X_train_scaled, y_train) # This line was moved after defining grid_search_before


# Training Model
#grid_search_before.fit(X_train_scaled, y_train) # This line is removed as it's already called above
best_logreg_before = grid_search_before.best_estimator_

# Evaluasi Model
y_pred_logreg_before = best_logreg_before.predict(X_test_scaled)
acc_logreg_before = accuracy_score(y_test, y_pred_logreg_before)

print("\nHyperparameter Terbaik Logistic Regression (Sebelum SMOTE):")
print(grid_search_before.best_params_)
print(f"\nLogistic Regression (Sebelum SMOTE, Scaling, Tuning): {acc_logreg_before:.4f}")
print(classification_report(y_test, y_pred_logreg_before))

# Fungsi untuk menampilkan dan menyimpan confusion matrix
def plot_confusion_matrix(y_true, y_pred, title, filename=None):
    cm = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(5, 4))
    sns.heatmap(cm, annot=True, fmt='g', cmap='Blues',
                xticklabels=['Benign', 'Malignant'],
                yticklabels=['Benign', 'Malignant'])
    plt.title(f'Confusion Matrix: {title}')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')

    # Simpan jika ada filename
    if filename:
        plt.tight_layout()
        plt.savefig(filename, dpi=300)

    plt.show()

# === Contoh penggunaan untuk Logistic Regression sebelum SMOTE ===
print("Logistic Regression (Sebelum SMOTE) - Confusion Matrix:")

# Buat folder jika belum ada
os.makedirs('models/logreg+rfe/', exist_ok=True)

# Tampilkan dan simpan confusion matrix
plot_confusion_matrix(
    y_test,
    y_pred_logreg_before,
    "Logistic Regression (Sebelum SMOTE)",
    filename='models/logreg+rfe//conmat-logreg+rfe.png'
)

# Menyimpan informasi lainnya ke dalam file pickle
pickle_data = {
    'model': best_logreg_before,
    'X_train': X_train,
    'X_test': X_test,
    'y_train': y_train,
    'y_test': y_test
}
with open('./models/logreg_model.pkl', 'wb') as f:
    pickle.dump(log_reg, f)
    
with open('models/logreg+rfe/data_file.pkl', 'wb') as f:
    pickle.dump(pickle_data, f)

# Simpan akurasi ke dalam file pickle
with open('models/logreg+rfe/akurasiakhir-logreg+rfe.pkl', 'wb') as f1:
    pickle.dump(acc_logreg_before, f1)

classification_report_str = classification_report(y_test, y_pred_logreg_before)
with open('models/logreg+rfe/cfreport-logreg+rfe.pkl', 'wb') as f2:
    pickle.dump(classification_report_str, f2)

prediksi = 'models/logreg+rfe/logreg+rfe.pkl'
pickle.dump(y_pred_logreg_before, open(prediksi, 'wb'))